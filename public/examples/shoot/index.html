<!doctype html>
<html lang="en">
  <head>
    <title>Physics Character Controls - Pointer Lock Example</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
    <link type="text/css" rel="stylesheet" href="main.css" />
  </head>
  <body>
    <div id="info">
      Physics character controls demo using Pointer Lock API <br />
      Move with WASD, look with the mouse, and jump with SPACE
    </div>
    <div id="container"></div>

    <script type="importmap">
      {
        "imports": {
          "physics-character-controls": "../../../dist/bundle.esm.js",
          "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';

      import Stats from 'three/addons/libs/stats.module.js';
      import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

      import { FirstPersonPointerLockControls } from 'physics-character-controls';
      import { PhysicsControlsHelper } from 'physics-character-controls';

      import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

      import { XRButton } from 'three/addons/webxr/XRButton.js';
			import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

      const container = document.getElementById('container');

      const gui = new GUI({ width: 200 });

      const clock = new THREE.Clock();

      const gltfLoader = new GLTFLoader();

      let controls;
      let helpers;

      gltfLoader.load('../../assets/models/collision-world.glb', (world) => {
        scene.add(world.scene);
        world.scene.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });

        controls = new FirstPersonPointerLockControls({
          object: camera,
          domElement: renderer.domElement,
          worldObject: world.scene,
          physicsOptions: {
            jumpForce: 0,
            groundMoveSpeed: 0,
            floatMoveSpeed: 0,
            boundary: {
              resetPoint: new THREE.Vector3(0, 0, 0),
              x: {
                min: -20,
                max: 30,
              },
              y: {
                min: -10,
                max: 20,
              },
              z: {
                min: -20,
                max: 30,
              },
            },
          },
        });
      });

      let monsterInterval
      let monsters = []

      Promise.all([
        gltfLoader.loadAsync('../../assets/models/monster.glb'),
      ]).then(([monster]) => {
        console.log('dad', monster)
        const monsterScene = monster.scene;
        monsterScene.position.set(0, -1, -2);

        scene.add(monster.scene);
        monsters.push(monster.scene);
        monsterInterval = setInterval(() => {
          console.log('monster', monster);
          const monsterClone = SkeletonUtils.clone(monsterScene);
          monsterClone.position.set(
            Math.random() * 20 - 10,
            -0.5,
            Math.random() * 20 - 10
          );
          console.log('scene', scene)
          console.log(monsterClone.position);
          scene.add(monsterClone);
        }, 1000);
      });

      // Scene
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      // Camera
      const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.rotation.order = 'YXZ';
      scene.add(camera);


      // Light
      const pointLight = new THREE.PointLight(0xffffff, 2, 20); // 초록빛 PointLight
      pointLight.position.set(0, 2, 0);
      scene.add(pointLight);

      const spotLight = new THREE.SpotLight(0xff5500, 30, 70, Math.PI / 6, 0.5);
      spotLight.position.set(0, 0, 1);
      camera.add(spotLight);
      spotLight.target = camera;

//       spotLight.position.set(0, 0, 0); // 카메라에 상대적인 위치 설정
// camera.add(spotLight); // 카메라의 자식으로 추가
// scene.add(camera); // 카메라를 씬에 추가

// // SpotLight Target 설정
// const lightTarget = new THREE.Object3D();
// lightTarget.position.set(0, 0, -1); // 카메라 기준으로 -Z 방향
// camera.add(lightTarget); // 카메라의 자식으로 추가
// spotLight.target = lightTarget; // SpotLight가 항상 -Z 방향 비추도록 설정

      // Renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setAnimationLoop(animate);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      container.appendChild(renderer.domElement);
      renderer.xr.enabled = true;

      // Stats
      const stats = new Stats();
      stats.domElement.style.position = 'absolute';
      stats.domElement.style.top = '0px';
      container.appendChild(stats.domElement);

      // XR
      document.body.appendChild( XRButton.createButton( renderer, {
        'optionalFeatures': [ 'depth-sensing' ],
        'depthSensing': { 'usagePreference': [ 'gpu-optimized' ], 'dataFormatPreference': [] }
      } ) );

      // XR controllers
      const raycaster = new THREE.Raycaster();

      function onSelectStart() {
          // 컨트롤러의 월드 좌표
          const position = new THREE.Vector3();
          const direction = new THREE.Vector3();
          
          // 컨트롤러의 위치와 방향 가져오기
          this.matrixWorld.decompose(position, new THREE.Quaternion(), new THREE.Vector3());
          direction.set(0, 0, -1).applyQuaternion(this.quaternion).normalize();
          
          // Raycaster 업데이트
          raycaster.set(position, direction);

          let closestObject = null;
          let closestDistance = Infinity;

          for (const object of monsters) {
              // 객체의 Bounding Box 계산
              if (!object.geometry.boundingBox) {
                  object.geometry.computeBoundingBox(); // 한 번만 계산
              }

              const boundingBox = object.geometry.boundingBox.clone();
              boundingBox.applyMatrix4(object.matrixWorld); // 월드 변환 적용

              // Ray와 Bounding Box의 교차점 계산
              const intersectionPoint = new THREE.Vector3();
              if (ray.intersectBox(boundingBox, intersectionPoint)) {
                  // Ray 원점과 교차점 간의 거리 계산
                  const distance = ray.origin.distanceTo(intersectionPoint);
                  if (distance < closestDistance) {
                      closestDistance = distance;
                      closestObject = object;
                  }
              }
          }

          if (closestObject) {
              // 가장 가까운 객체 선택
              console.log('closest object:', closestObject);
          }
      }


      const controller1 = renderer.xr.getController( 0 );
      controller1.addEventListener( 'selectstart', onSelectStart );
      controller1.addEventListener( 'connected', function ( event ) {

        this.add( buildController( event.data ) );

      } );
      controller1.addEventListener( 'disconnected', function () {

        this.remove( this.children[ 0 ] );

      } );
      scene.add( controller1 );

      const controller2 = renderer.xr.getController( 1 );
      controller2.addEventListener( 'selectstart', onSelectStart );
      controller2.addEventListener( 'connected', function ( event ) {

        this.add( buildController( event.data ) );

      } );
      controller2.addEventListener( 'disconnected', function () {

        this.remove( this.children[ 0 ] );

      } );
      scene.add( controller2 );

      // The XRControllerModelFactory will automatically fetch controller models
      // that match what the user is holding as closely as possible. The models
      // should be attached to the object returned from getControllerGrip in
      // order to match the orientation of the held device.

      const controllerModelFactory = new XRControllerModelFactory();

      const controllerGrip1 = renderer.xr.getControllerGrip( 0 );
      controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
      scene.add( controllerGrip1 );

      const controllerGrip2 = renderer.xr.getControllerGrip( 1 );
      controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
      scene.add( controllerGrip2 );

      
			function buildController( data ) {

				let geometry, material;

				switch ( data.targetRayMode ) {

					case 'tracked-pointer':

						geometry = new THREE.BufferGeometry();
						geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );
						geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );

						material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );

						return new THREE.Line( geometry, material );

					case 'gaze':

						geometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );
						material = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );
						return new THREE.Mesh( geometry, material );

				}

			}

      function animate() {
        const delta = Math.min(0.05, clock.getDelta());

        controls && controls.update(delta);

        helpers && helpers.update();

        renderer.render(scene, camera);

        // spotlight.s

        stats.update();
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      window.addEventListener('resize', onWindowResize);

      // Dispose function
      function dispose() {
        renderer.setAnimationLoop(null);

        window.removeEventListener('resize', onWindowResize);

        controls && controls.disconnect();
        helpers && helpers.dispose();
        renderer.dispose();

        monsterInterval && clearInterval(monsterInterval);

        // Dispose of scene objects
        scene.traverse(object => {
          if (object.isMesh) {
            object.geometry.dispose();

            if (Array.isArray(object.material)) {
              object.material.forEach(material => material.dispose());
            } else if (object.material) {
              object.material.dispose();
            }
          }
        });

        // Remove renderer DOM element
        if (renderer.domElement && renderer.domElement.parentNode) {
          renderer.domElement.parentNode.removeChild(renderer.domElement);
        }
      }

      window.addEventListener('beforeunload', dispose);
    </script>
  </body>
</html>
